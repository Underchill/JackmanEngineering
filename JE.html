<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telescoping Toilet Flange 3D Visualizer</title>
    
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load three.js (the 3D library) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 3. Load OrbitControls (for mouse interaction) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- 4. Load MTLLoader (for .mtl materials) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <!-- 5. Load OBJLoader (for .obj geometry) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    
    <style>
        /* Use the Inter font, as per instructions */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure the canvas is a block element to prevent layout issues */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Make html and body take full height */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Hide page scrollbars */
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen font-sans">

    <!-- Main content card -->
    <!-- Increased max-width from 4xl to 6xl for the side-by-side layout -->
    <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 w-11/12 max-w-5xl max-h-[190vh] flex flex-col">
        
        <!-- Header -->
        <div class="flex-shrink-0">
            <h1 class="text-2xl md:text-3xl font-bold text-slate-800">Telescoping Toilet Flange 3D Visualizer</h1>
            <p class="text-slate-600 mt-2">
                Click and drag to rotate the model. Use the scroll wheel to zoom.
            </p>
        </div>

        <!-- 
          NEW: Content container for columns 
          This stacks on mobile (flex-col) and goes side-by-side on desktop (md:flex-row)
          min-h-0 prevents flexbox overflow issues
        -->
        <div class="flex-grow flex flex-col md:flex-row mt-6 gap-6 min-h-0">

            <!-- 
              Column 1: Canvas Container
              Takes 60% of width on desktop, full width on mobile.
              min-h-[300px] for mobile, h-full on desktop.
            -->
            <div id="canvas-container" class="w-full md:w-3/5 rounded-lg overflow-hidden bg-slate-200 relative min-h-[300px] md:min-h-0">
                <!-- This is the canvas our 3D scene will be rendered into -->
                <!-- The CSS 'canvas { width: 100%; height: 100% }' will make it fill this div -->
                <canvas id="model-canvas"></canvas>
                
                <!-- Loading indicator -->
                <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center bg-slate-200 bg-opacity-80 p-4">
                    <div class="text-slate-700 font-semibold">Loading 3D model...</div>
                </div>
            </div>

            <!-- 
              Column 2: Text Box
              Takes 40% of width on desktop, full width on mobile.
              Uses flex-col to allow text area to grow and scroll.
            -->
            <div class="w-full md:w-2/5 flex flex-col min-h-[200px] md:h-full">
                <h2 class="text-xl font-semibold text-slate-700 mb-3 flex-shrink-0">Model Details</h2>
                <!-- 
                  This div holds the text. 
                  flex-grow: makes it fill the available space in this column.
                  overflow-y-auto: adds a scrollbar if content overflows.
                  prose: from tailwind typography for nice text styling.
                -->
                <div class="prose prose-slate bg-slate-50 border border-slate-200 rounded-lg p-4 flex-grow overflow-y-auto">
                    <p>Abstract</p>
                    <p>A telescoping toilet mounting assembly and a method for mounting a toilet to a floor and a wastewater pipe. Hollow bolts project from clamping plates to be received through mounting holes in an upper male flange section and through mounting holes of a toilet base. Base bolt nuts are tightened onto the hollow bolts to secure the upper male flange section to the toilet base prior to lowering the toilet and the upper male flange section into engagement with a lower female flange section. Fastening bolt structures with adjustable-length body portions and threaded tips can pass through the hollow bolts and into threaded engagement with mounting members fixed to the lower female flange section fixed to the wastewater pipe and the floor. Alternatively, fastening bolts pass through the hollow bolts and into threaded engagement with upstanding registration and locking rods retained relative to the lower female flange section.</p>
                </div>
            </div>

        </div> <!-- End of columns container -->

    </div> <!-- End of main card -->

    <!-- The JavaScript for setting up the 3D scene -->
    <script type="module">
        // Find the canvas and its container
        const canvas = document.getElementById('model-canvas');
        const container = document.getElementById('canvas-container');
        const loadingIndicator = document.getElementById('loading-indicator');

        // ======== 1. Core Three.js Components ========
        
        // Scene: This is the container for all our 3D objects
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x858585); // Match page background

        // new THREE.PerspectiveCamera(FieldOfView, AspectRatio, NearClip, FarClip)
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            container.clientWidth / container.clientHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        // Move the camera back so we can see the model
        camera.position.set(0, 10, 30);

        // Renderer: This draws the scene onto the canvas
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas, 
            antialias: true // Makes edges look smoother
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // For sharp rendering on high-DPI screens

        // ======== 2. Lights ========
        
        // Ambient Light: Illuminates all objects in the scene equally
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Directional Light: Shines from a specific direction (like the sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // ======== 3. Load the .OBJ Model ========
        
        let loadedModel;

        const mtlLoader = new THREE.MTLLoader();
        const objLoader = new THREE.OBJLoader();
        const mtlPath = './webvis.mtl'; // <-- REPLACE THIS
        const objPath = './webvis.obj'; // <-- REPLACE THIS
        
        mtlLoader.load(mtlPath, (materials) => {
            materials.preload();
            objLoader.setMaterials(materials);
            
            objLoader.load(objPath, (object) => {
                // The 'object' is a THREE.Group containing your model's meshes
                
                // --- Optional: Auto-center and scale the model ---
                // This is helpful as models can be at any position or scale
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Rescale to a reasonable size
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 20 / maxDim; // We want it to be ~20 units big
                object.scale.set(scale, scale, scale);
                
                // Move to origin
                object.position.sub(center.multiplyScalar(scale));
                // --- End of auto-center ---
                
                scene.add(object);
                loadedModel = object; // Store for access in animate()
                
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
                
            }, 
            (xhr) => {
                // Called while loading is progressing
                const percentLoaded = (xhr.loaded / xhr.total) * 100;
                if (loadingIndicator.style.display !== 'none' && mtlPath !== 'path/to/your/model.mtl') {
                    loadingIndicator.innerHTML = `<div class="text-slate-700 font-semibold">Loading... ${Math.round(percentLoaded)}%</div>`;
                }
            }, 
            (error) => {
                // Called when loading fails
                console.error('An error happened during .obj loading', error);
                loadingIndicator.innerHTML = `<div class="text-red-600 font-semibold text-center">An error happened during .obj loading.</div>`;
            });
            
        }, 
        (xhr) => {
             // Called while loading .mtl is progressing
             loadingIndicator.innerHTML = `<div class="text-slate-700 font-semibold">Loading materials...</div>`;
        },
        (error) => {
            // Called when .mtl loading fails
            console.error('An error happened during .mtl loading', error);
             loadingIndicator.innerHTML = `<div class="text-red-600 font-semibold">Error loading materials...</div>`;
        });


        // ======== 4. Controls ========
        
        // OrbitControls: Allows mouse interaction (orbit, zoom, pan)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Adds a smooth "coasting" effect
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;  // Adjusted min distance
        controls.maxDistance = 100; // Don't let user get too far

        // ======== 5. The Animation Loop ========
        
        // This function is called 60 times per second to re-render the scene
        function animate() {
            requestAnimationFrame(animate);

            // Gently rotate the model on its own, if it has loaded
            if (loadedModel) {
                loadedModel.rotation.y += 0.003;
            }

            // Update the controls (needed for damping)
            controls.update();

            // Render the final scene from the camera's perspective
            renderer.render(scene, camera);
        }

        // Start the animation loop!
        animate();

        // ======== 6. Handle Window Resizing ========

        function onWindowResize() {
            // Get the new dimensions of the container
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Update the camera's aspect ratio
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Update the renderer's size
            renderer.setSize(width, height);
        }

        // Listen for resize events on the window
        window.addEventListener('resize', onWindowResize);
        
    </script>

</body>
</html>

